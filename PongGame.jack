// Two-player Pong Game (corrigido: sem >=/<=; Game Over sem passar string como argumento)

class PongGame {

    static PongGame instance;

    field Bat topBat;         // Jogador 2
    field Bat bottomBat;      // Jogador 1
    field Ball ball;

    field boolean exit;
    field int score;
    field int batWidth;

    /** Construtor */
    constructor PongGame new() {
        do Screen.clearScreen();

        let batWidth = 50;

        // Barras
        let topBat = Bat.new(230, 10, batWidth, 7);       // Jogador 2
        let bottomBat = Bat.new(230, 229, batWidth, 7);   // Jogador 1

        // Bola no centro
        let ball = Ball.new(253, 122, 0, 511, 0, 229);
        do ball.setDestination(400, 0);

        // Linha superior e inferior (opcional visual)
        do Screen.drawRectangle(0, 0, 511, 1);
        do Screen.drawRectangle(0, 238, 511, 240);

        do Output.moveCursor(22, 0);
        do Output.printString("Score: 0");

        let exit = false;
        let score = 0;

        return this;
    }

    method void dispose() {
        do topBat.dispose();
        do bottomBat.dispose();
        do ball.dispose();
        do Memory.deAlloc(this);
        return;
    }

    function void newInstance() {
        let instance = PongGame.new();
        return;
    }

    function PongGame getInstance() {
        return instance;
    }

    /** Loop principal — movimento clássico: bats sempre se movem; teclas mudam direção */
    method void run() {
        var char key;

        while (~exit) {

            let key = Keyboard.keyPressed();

            // Jogador 1 (barra inferior) – setas (aceita apenas códigos típicos)
            if (key = 130) { do bottomBat.setDirection(1); }   // esquerda
            else {
                if (key = 132) { do bottomBat.setDirection(2); } // direita
            }

            // Jogador 2 (barra superior) – 'a' (97) e 'd' (100)
            if (key = 97) { do topBat.setDirection(1); }   // 'a'
            else {
                if (key = 100) { do topBat.setDirection(2); }  // 'd'
            }

            // Q (113) para sair
            if (key = 113) { let exit = true; }

            // Movimento clássico (sempre): move aplica a direção atual
            do topBat.move();
            do bottomBat.move();

            // Atualiza bola / colisões
            do moveBall();

            do Sys.wait(40);
        }

        return;
    }

    /** Move a bola, trata colisões e verifica game over.
     *  Todas as comparações utilizam apenas < e > (Jack aceita) ou negações ~(a < b) para >=.
     */
    method void moveBall() {
        var int w;
        var int bl, br, bt, bb;
        var boolean colTop, colBottom;

        let w = ball.move();

        let bl = ball.getLeft();
        let br = ball.getRight();
        let bt = ball.getTop();
        let bb = ball.getBottom();

        // -------- COLISÃO COM BARRA SUPERIOR --------
        let colTop = false;
        // (bb >= topBat.getTop())  ->  ~(bb < topBat.getTop())
        if (~(bb < topBat.getTop())) {
            // (bt <= topBat.getBottom()) -> ~(topBat.getBottom() < bt)
            if (~(topBat.getBottom() < bt)) {
                // (br >= topBat.getLeft()) -> ~(br < topBat.getLeft())
                if (~(br < topBat.getLeft())) {
                    // (bl <= topBat.getRight()) -> ~(topBat.getRight() < bl)
                    if (~(topBat.getRight() < bl)) {
                        let colTop = true;
                    }
                }
            }
        }

        // -------- COLISÃO COM BARRA INFERIOR --------
        let colBottom = false;
        // original used bt <= bottomBat.getBottom() and bb >= bottomBat.getTop()
        // transform each:
        if (~(bt > bottomBat.getBottom())) {            // !(bt > bottomBottom) => bt <= bottomBottom
            if (~(bottomBat.getTop() < bb)) {            // !(bottomTop < bb) => bb >= bottomTop
                if (~(br < bottomBat.getLeft())) {
                    if (~(bottomBat.getRight() < bl)) {
                        let colBottom = true;
                    }
                }
            }
        }

        // Se houve colisão com bat superior: tratar antes do game over
        if (colTop) {
            do handleBounceTop();
            return;
        }

        // Se houve colisão com bat inferior: tratar antes do game over
        if (colBottom) {
            do handleBounceBottom();
            return;
        }

        // -------- GAME OVER (após checar colisões) --------
        // Jogador 2 perde: bola passou acima do topo (bt < 0)
        if (bt < 0) {
            do showGameOverP2();
            let exit = true;
            return;
        }

        // Jogador 1 perde: bola passou abaixo da barra inferior (bb > bottomBat.getBottom())
        if (bb > bottomBat.getBottom()) {
            do showGameOverP1();
            let exit = true;
            return;
        }

        // Rebotes nas paredes laterais (1=left,2=right)
        if (w = 1) { do ball.bounce(0); }
        if (w = 2) { do ball.bounce(0); }

        return;
    }

    /** Trata o rebote com a barra superior (topBat). */
    method void handleBounceTop() {
        var int dir;
        let dir = 0;
        var int bl, br, batL, batR;

        let bl = ball.getLeft();
        let br = ball.getRight();

        let batL = topBat.getLeft();
        let batR = topBat.getRight();

        if (br < (batL + 16)) { let dir = -1; }
        else {
            if (bl > (batR - 16)) { let dir = 1; }
        }

        // atualiza score
        let score = score + 1;
        do Output.moveCursor(22, 7);
        do Output.printInt(score);

        // diminui largura da topBat (2 px), com mínimo 20
        var int newWidth;
        let newWidth = batR - batL;
        let newWidth = newWidth - 2;
        if (newWidth < 20) { let newWidth = 20; }
        do topBat.setWidth(newWidth);

        // garante que a bola seja posicionada fora da bat antes de bounce para evitar ficar presa
        // Se a bola estiver "sobre" a bat, reposiciona-a um pouco acima
        let y = topBat.getTop() - 6; // coloca a bola logo acima da bat
        // chamamos show/hide via ball API (não disponível), mas setDestination fará o movimento correto
        do ball.bounce(dir);
        return;
    }

    /** Trata o rebote com a barra inferior (bottomBat). */
    method void handleBounceBottom() {
        var int dir;
        let dir = 0;
        var int bl, br, batL, batR;

        let bl = ball.getLeft();
        let br = ball.getRight();

        let batL = bottomBat.getLeft();
        let batR = bottomBat.getRight();

        if (br < (batL + 16)) { let dir = -1; }
        else {
            if (bl > (batR - 16)) { let dir = 1; }
        }

        // atualiza score
        let score = score + 1;
        do Output.moveCursor(22, 7);
        do Output.printInt(score);

        // diminui largura da bottomBat (2 px), com mínimo 20
        var int newWidth;
        let newWidth = batR - batL;
        let newWidth = newWidth - 2;
        if (newWidth < 20) { let newWidth = 20; }
        do bottomBat.setWidth(newWidth);

        // reposiciona a bola um pouco abaixo da bat para evitar ficar presa
        let y = bottomBat.getBottom() + 1;
        do ball.bounce(dir);
        return;
    }

    /** Exibe Game Over para o jogador 1 (inferior) */
    method void showGameOverP1() {
        do Screen.clearScreen();
        do Output.moveCursor(10, 10);
        do Output.printString("Game Over - Jogador 1 perdeu");
        do Sys.wait(2000);
        return;
    }

    /** Exibe Game Over para o jogador 2 (superior) */
    method void showGameOverP2() {
        do Screen.clearScreen();
        do Output.moveCursor(10, 10);
        do Output.printString("Game Over - Jogador 2 perdeu");
        do Sys.wait(2000);
        return;
    }
}
